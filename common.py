
# We represent the cells of the board
#
#   o o o o o o
#    o o o o o o
#   o o o o o o
#    o o o o o o
#
# as
#
#     o o o o o o
#     o o o o o o
#   o o o o o o
#   o o o o o o

BOARD = frozenset([     (1,0), (2,0), (3,0), (4,0), (5,0), (6,0),
                        (1,1), (2,1), (3,1), (4,1), (5,1), (6,1),
                 (0,2), (1,2), (2,2), (3,2), (4,2), (5,2),
                 (0,3), (1,3), (2,3), (3,3), (4,3), (5,3)])

# We represent the directions
#
#     ul ur
#    l  o  r
#     dl dr
#
# as
#
#          (0,-1) (1,-1)
#   (-1,0)        (1,0)
#   (-1,1) (0,1)

L = (-1,0)
R = (1,0)
UL = (0,-1)
UR = (1,-1)
DL = (-1,1)
DR = (0,1)
C = (0,0)


DIRECTIONS = frozenset([L, R, UL, UR, DL, DR])
SLOTS = DIRECTIONS | frozenset([C])


def compose_isos(iso1, iso2):
    """ Composes two isometries """
    ret = {}
    for s in SLOTS:
        ret[s] = iso1[iso2[s]]
    return ret

# The possible rotations of directions are generated by:
TICK_RIGHT = {C:C, UL: UR, UR: R, R: DR, DR: DL, DL: L, L: UL}
# But we can also mirror:
FLIP = {C:C, UL: UR, UR: UL, L: R, R: L, DL: DR, DR: DL}
# All isometries are given by:
ISOMETRIES = []
current_iso = TICK_RIGHT
for i in xrange(5):
    ISOMETRIES.append(('r'*(i+1),current_iso))
    current_iso = compose_isos(current_iso, TICK_RIGHT)
ISOMETRIES.append(('I', {C:C, R:R, L:L, UL:UL, UR:UR, DR:DR, DL:DL}))
current_iso = FLIP
for i in xrange(6):
    ISOMETRIES.append(('f'+('r'*i),current_iso))
    current_iso = compose_isos(current_iso, TICK_RIGHT)
del(current_iso)

ISOS_BY_NAME = dict(ISOMETRIES)

# Useful rotation
ANTIPODAL = {UL: DR, UR: DL, R: L, DR: UL, DL: UR, L: R}


# A piece consists out of several linked bits.  A bit is either a peg or
# a (wide open/small open/closed) hole in a certain direction.
# We can represent a bit by the slots it occupies.  The slots of a cell are
# the directions plus a center.  Examples:
#    A closed hole bit will occupy all directions, but not the center.
#    A peg bit in the directed to the right  will occupy the center and the
#            left direction.
#    A small open hole bit directed to the right will occupy all direction
#           slots except for the right.  It will not occupy the center.

def peg(direction):
    return frozenset([ANTIPODAL[direction], C])
CLOSED_HOLE = DIRECTIONS
def hole(direction):
    return DIRECTIONS - frozenset([direction])
def wide_hole(direction1, direction2):
    return DIRECTIONS - frozenset([direction1, direction2])
def double_peg(direction1, direction2):
    return frozenset([direction1, direction2, C])

# The pieces are defined as a list of (slot,bit) pairs.
PIECES = {
        'red-vee': [          (C, hole(L)), (R, peg(R)),
                        (DL, peg(DL))],
        'purple-vee': [       (C, CLOSED_HOLE), (R, hole(UL)),
                        (DL, peg(DL))],
        'pink-vee': [         (C, CLOSED_HOLE), (R, hole(DL)),
                        (DL, peg(DL))],
        'yellow-vee': [        (C, CLOSED_HOLE), (R, hole(R)),
                        (DL, hole(DR))],
        'blue-vee': [          (C, CLOSED_HOLE), (R, hole(DR)),
                        (DL, peg(DL))],
        'purple-line': [ (L, peg(L)), (C, wide_hole(UL, UR)), (R, peg(R))],
        'lime-line': [ (UL, hole(DL)),
                          (C, CLOSED_HOLE),
                             (DR, peg(DR))],
        'green-line': [ (UL, hole(L)),
                           (C, CLOSED_HOLE),
                              (DR, peg(DR))],
        'green-triangle': [         (C, double_peg(DL, DR)),
                            (DL, hole(DL)),    (DR, peg(DR))],
        'orange-triangle': [         (C, hole(UL)),
                            (DL, peg(DL)), (DR, peg(DR))],
        'red-triangle':  [           (C, hole(UL)),
                            (DL, peg(DL)), (DR, hole(UR))],
        'blue-triangle': [          (C, double_peg(DL, DR)),
                            (DL, hole(DR)), (DR, peg(DR))]}

def transform_piece(piece, iso):
    """ Rotates/flips the piece according to iso. """
    return frozenset([(iso[d], frozenset([iso[d2] for d2 in sl]))
                    for (d, sl) in piece])

def move(cell, direction):
    """ Go from one cell to another by moving in the given direction. """
    return (cell[0] + direction[0],
            cell[1] + direction[1])
